package ru.kontur.vostok.hercules.stream.manager;

import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AlterConfigsResult;
import org.apache.kafka.clients.admin.Config;
import org.apache.kafka.clients.admin.ConfigEntry;
import org.apache.kafka.clients.admin.CreatePartitionsResult;
import org.apache.kafka.clients.admin.CreateTopicsResult;
import org.apache.kafka.clients.admin.DeleteTopicsResult;
import org.apache.kafka.clients.admin.NewPartitions;
import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.common.config.ConfigResource;
import org.apache.kafka.common.config.TopicConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * @author Gregory Koshelev
 */
public class KafkaManager {

    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaManager.class);

    private final AdminClient adminClient;
    private final short replicationFactor;

    public KafkaManager(Properties properties, short replicationFactor) {
        this.adminClient = AdminClient.create(properties);
        this.replicationFactor = replicationFactor;
    }

    public void createTopic(String topic, int partitions, Long ttl) {
        Map<String, String> configs = new HashMap<>();
        if (ttl != null) {
            configs.put("retention.ms", ttl.toString());
        }
        //TODO: Replicas assignment should be used
        NewTopic newTopic = new NewTopic(topic, partitions, replicationFactor)
                .configs(configs);
        CreateTopicsResult result = adminClient.createTopics(Collections.singletonList(newTopic));
        Future<Void> future = result.values().get(topic);
        try {
            future.get();
        } catch (Exception e) {
            LOGGER.error("Topic creation fails with exception", e);
        }
    }

    public void changeTtl(String topic, Long ttl) {
        ConfigResource resourceConfig = new ConfigResource(ConfigResource.Type.TOPIC, topic);
        ConfigEntry retentionConfigEntry = new ConfigEntry(TopicConfig.RETENTION_MS_CONFIG, ttl.toString());

        Map<ConfigResource, Config> updateConfig = new HashMap<>();
        updateConfig.put(resourceConfig, new Config(Collections.singleton(retentionConfigEntry)));
        AlterConfigsResult result = adminClient.alterConfigs(updateConfig);

        Future<Void> future = result.values().get(resourceConfig);
        try {
            future.get();
        } catch (Exception e) {
            LOGGER.error("Change of ttl fails with exception", e);
        }
    }

    public void increasePartitions(String topic, int newPartitions) {
        NewPartitions request = NewPartitions.increaseTo(newPartitions);
        CreatePartitionsResult result = adminClient.createPartitions(Collections.singletonMap(topic, request));
        Future<Void> future = result.values().get(topic);
        try {
            future.get();
        } catch (Exception e) {
            LOGGER.error("Increasing of partitions count fails with exception", e);
        }
    }

    public void deleteTopic(String topic) {
        DeleteTopicsResult result = adminClient.deleteTopics(Collections.singletonList(topic));
        Future<Void> future = result.all();
        try {
            future.get();
        } catch (Exception e) {
            LOGGER.error("Topic deletion fails with exception", e);
        }
    }

    public void close(long duration, TimeUnit unit) {
        adminClient.close(duration, unit);
    }
}
